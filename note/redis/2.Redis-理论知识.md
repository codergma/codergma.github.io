# 1.数据持久化方式
1. **RDB**：通过save和bgsave命令，保存内存中的键值对。  
> * save命令是redis主进程执行数据持久化，此时redis接收到的所有命令都会被阻塞。  
> * bgsave命令是子进程执行数据持久化，此时redis接收到的命令不会被阻塞；  
> * redis可以通过配置save选项来执行bigsave命令，进行自动间隔性保存； 

**RDB同步存在的问题：**   
> 如果服务器宕机，最后一次bgsave之后内存中修改的数据会丢失。
2. **AOF(Append Only File)**: 通过保存redis服务器执行的写入命令来保存数据库状态。 
AOF的实现方式:命令追加、文件写入、文件同步。
>* 命令追加指的是将写入命令追加到aof_buf缓冲区的末尾；  
>* 文件写入指的是将aof_buf中的内容写入到文件，但现代操作系统也是先将数据写到了内存缓冲区；  
>* 文件同步指的是将内存缓冲区中的内容同步到磁盘。  

**AOF同步存在的问题:**  
> 随着服务器的运行，aof文件会越来越大，解决方案是BGREWIRTEAOF.  

redis服务器进程就是一个时间循环，每个循环可能会有数据追加到aof_buf，所以在每个循环中都会执行flushAppendOnlyFile函数，此函数会检查aof_buf中的内容，并进行文件写入和文件同步，具体的同步策略由appendfsyn选项决定。
  
| appendfsync选项的值 |  	flushAppendOnlyFile的行为 | 
|---------------------------|----------------------------------- |
|always|将aof_buf中的所有内容写入并同步到AOF文件中 |	
|everysec|将aof_buf中的所有内容写入到AOF文件中，如果上次同步时间超过1s,那么再次对这个文件进行同步，并且同步是由专门的线程操作|	
|no|将aof_buf中的内容写入AOF文件，但不进行同步，什么时候同步由操作系统决定|	  
3. **AOF重写**  
随着服务器的运行，AOF文件体积会越来越大，影响Redis性能，并且进行数据还原的时候需要的时间也越来越多，所以诞生了AOF重写：BGREWRITEAOF； 

>AOF重写不需要对原来的AOF文件进行任何读写和分析操作，而是根据数据库中的状态来实现的：
>1. 子进程遍历数据库中的数据，执行写入操作；
>2. 在此期间，主进程执行的写入命名同步到aof重写缓冲区；
>3. 子进程处理完成后向主进程发送一个信号，这时候主进程会将aof重写缓冲区的内容写到新的AOF文件中，并将新的aof文件重命名，原子化的覆盖原来的aof文件。

# 2.主从同步机制
redis的同步功能分为同步(sync)和命令传播(command propagate)。  

同步的过程：
>1. 从服务器向主服务器发送PSYNC命令;
>2. 主服务器执行BGSAVE命令,生成RDB文件，并将RDB文件发送给从服务器;
>3. 从服务器接收并同步RDB文件;
>4. 主服务器向从服务器发送缓冲区的写命令;
>5. 从服务器接收命令，并执行，同步完成。  

命令传播过程：
>同步完成之后，主服务器一旦有写入命令就会将自己的写命令发送给从服务器，保持主从服务器状态的一致。  

reddis2.8之后实现了部分重同步功能，部分重同步的实现：
>1. 主服务器的复制偏移量和从服务器的复制偏移量(replication offset)，通过对比偏移量，确认主从是否处于一致状态；
>2. 主服务器的复制积压缓冲区（replication backlog)，通过积压缓冲区查找和发送连接断开后丢失的命令；
>3. 服务器运行ID（run ID)，通过运行ID判断是执行完整重同步还是部分重同步；