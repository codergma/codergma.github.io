准备
===

### 网络协议
```
http状态码：
200
301:move permantenly
302:move temporarily
304:Not Modified
400:Bad Request 语义或参数有误
401:Unauthorized,未授权
403：Forbidden,服务器理解这个请求，但是拒绝执行
404：Not Found,服务器上没有这个资源
500：Internal server error,服务端发生未知错误
502：Bad Gateway,比如php-fpm直接挂掉
503：Server unavailable，服务当前无法使用
504：Gateway Timeout，比如php-fpm超时未返回

OSI七层网络模型
Http工作原理：客户端与服务端建立一个TCP连接，制定端口号，服务器监听客户端氢请求，并相应
HTTP特点：基于B/S模式，通信开销小，简单快速，传输陈本低，无状态
HTTP报文格式：起始行，头部，主体
HTTP请求头：
accept：支持的数据类型text/html,image/jpg
accept-encoding：压缩格式
accept-language：语言环境
catch-control：是否缓存
connection：是否保持连接
cookie
referer
user-agent
响应头：
connect-type：回送的数据类型
catch-control:是否缓存
connection：是否保持连接
HTTP请求方法：GET（获取）HEAD(同GET，但部分会主体）POST(创建）PUT（修改）DELETE(删除）OPTIONS(请求服务器告知其支持的各种功能）TRACE
HTTPS是在HTTP协议基础上，添加了SSL/TSL握手以及加密功能，也是应用层协议。
FTP：文件传输协议，端口21
Telnet：远程登录协议，端口23
SMTP：简单邮件传输协议，端口25
POP3：接收邮件，端口110
HTTP：超文本传输协议，端口80
DNS：域名解析服务，端口53

```
### Linux命令
```
系统安全：su,sudu，visudo, chmod, chown
进程管理：w,top,ps,kill,pkill,pstree
用户管理：useradd,userdel,passwd,groupadd,id,
文件系统：mount,unmount,df,du,
网络应用：curl,telnet,
网络测试：ping,host,netstat
网络配置：hostname,ifconfig
文件查找：find,locate
grep ,awk, sed, cat, tail, 
netstat, ps, 
curl
crontab

```

### MYSQL
```
char:存储短的或长度相似的字符串；超出长度被截断；
varchar:存储变长字符串；超出长度被截断；
对于经常变更的数据，char比varchar更好，因为varchar会产生数据碎片；对于非常短的列char比varchar更有效率；尽量避免使用blob/text，因为查询会使用临时表；
```
```
InnoDB:事务存储引擎；支持外键；支持行级锁；支持故障恢复；支持热备份；
MyISAM:支持全文索引、压缩、空间函数；不支持事务；表级锁；不支持故障恢复；
InnoDB 和 MyISAM区别
锁机制：共享锁&排它锁
存储过程：
触发器：
```
索引
```
索引对性能的影响：减少扫描的数据量；避免排序；避免使用临时表；将随机I/O变成书顺序I/O;提高查询速度；降低写入速度；占用磁盘空间；
索引的创建原则：经常出现在where或join后面的列；所以列的基数越大，效果越好；字符串索引制定前缀长度，节省索引空间；创建联合索引提高查询速度；避免过多索引，节省磁盘空间；主键选择较短的数据类型，节约磁盘空间；
索引注意事项：
复合索引遵循左前原则；
like查询，%不能放前面；
column is null也可以用到索引；
mysql认为如果比全表扫描慢，就放弃使用索引；
or前的列有索引，后面的没有索引，则两个索引都不会用到；
字符串索引要加引号，不然用不到索引；
一个查询只会用到一个索引；
```
sql
```
关联更新
UPDATE A,B SET A.c1=B.c1, A.c2=B.c2 WHRER A.id=B.id;
UPDATE A INNER JOIN B ON A.id=B.id SET A.c1=B.c1, A.c2=B.c2 WHERE;
关联查询
交叉连接：
SELECT * FROM A CROSS JOIN B CROSS JOIN C WHERE;
SELECT * FROM A,B,C WHERE;
没有关联条件，笛卡尔集，无意义
内连接：
SELECT * FROM A INNER JOIN B ON A.id=B.id;
SELECT * FROM A,B WHERE A.id=B.id;
多表中同时符合某种条件的值得集合；
左外连接&右外链接：LEFT JOIN, RIGHT JOIN;
联合查询:
SELECT id FROM A UNION SELECT id2 from B ;
两个表的列数必须一样；相同的值会被合并（UNION ALL不会合并）；
全连接：mysql不支持，但是可用通过LEFT JOIN,RIGHT_JOIN,UNION实现
SELECT * FROM A LEFT JOIN B ON A.id=B.id UNION
SELECT * FROM A RIGHT JOIN B ON A.id=B.id;
嵌套查询：不推荐使用，效率不好控制
SELECT * FROM A WHERE A.id in (SELECT B.id FROM B)；
```

### 高可用&高扩展
```
1.分区表的工作原理：
对用户来说，分区表示一个独立的逻辑表，但mysq底层使用多个物理子表；使用partition by 定义表；
场景：1.数据量很大，只有最后的数据是热点数据；2.更容易维护；3.存储到不同的机器上；4.避免某些瓶颈；

2.分表：
水平分表： 
垂直分表：数据行变小，一个数据也存储更多数据，减少I/O;
```
### Mysql复制原理&负载均衡
```
1.主从复制的原理：
	主库把数据更改写到binlog；
	从库将主库的binlo同步到自己的中继日志；
	从库回放中继日志；
2.主从复制解决的问题：
	数据分布：可以分布在不同的地理位置；
	负载均衡：减少单点压力；
	高可用和故障切换：避免单点失败；
	升级测试：用一个高版本的作为测试库；
3.mysql主键索引的叶子节点存放的是完整的数据，辅助索引的叶子节点存放的是主键索引；聚簇索引不是一种单独的索引类型，而是一种数据存储方式，innodb中实际上是一个结构保存了索引和数据行（主键就是聚簇索引）
```
### Mysql安全
```
安全设置：
	1.备份
	2.权限控制
	3.关闭远程访问的权限

sql语句的安全：
	1.使用预处理语句，防止sql注入
	2.特殊字符转义
	3.错误信息不要返回用户
```
### 算法
```
#冒泡排序 时间：最差O(n^2) 平均O(n^2) 空间O(1)
#直接插入排序 时间：O(n^2) O(n^2) 空间O（1）
#希尔排序 时间：O(n^2) O(n^2) 空间O（1)
#选择排序  时间：O(n^2) O(n^2) 空间O(1)
#快速排序  时间：O(n^2) O(nlog2n) 空间O（n) O(log2n)
#堆排序	  时间：O(nlog2n) O(nlog2n) 空间 O(1)
#归并排序 时间：O(nlog2n) O(nlog2n) 空间 O(1)
#时间复杂度 O(1)<O(log2n)<O(n)<O(nlog2n)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)
#空间复杂度
查找算法：
二分法：时间：O(log2n) O(log2n) 迭代： O(1) 递归：O(log2n)
顺序查找：
```
### 常见数据结构
```
array：采用连续的内存存储，可以通过下表访问，元素必须相同的类型或类型衍生。(这里说的是数组的通用概念，php的数组不是真正意义上的数组）
linkedlist:元素是一对一的关系，有顺序存储和链式存储两种存储方式。
doubly-lined-list:双向链表
stack:先进后出，只有一个出口，只能从顶部增加和移除元素。
queue:队列，先进先出
Heap：子节点的键值或索引总是小于父节点，每个节点的左右子树又是一个二叉堆。
set:集合，保存不重复元素
map:字典，关联数组或键值对
graph
```
### nginx和apache的区别
```
nginx处理请求是异步非阻塞的，apache是阻塞的，所以nginx处理高并发的能力强，占用资源小;
apache可以处理动态内容，nginx只能处理静态内容;
轻量级，nginx占用更少的资源；
nginx高度模块化；
apache rewrite功能强大；

```


### MYSQL

1. 为什么不适用二叉树
二叉树的高度太高，导致查询次数变多，且左右子树不平衡，极端情况是分布在同一侧；
2. 为什么使用B+树而不是B树
磁盘读写效率高：B+树的非叶子节点只保存索引，所以相比B树节点更小，同一盘块中容纳的关键字就越多，一次性读入内存的关键字就多，所以磁盘I\O次数就少。
查询效率稳定：非叶子节点不保存具体的内容，所有查询必须从根节点走到叶子节点，查询路径相同。
区间访问：所有叶子节点通过指针关联起来，这样就能通过叶子节点遍历。
3. MyISAM 和 InnoDB的区别
4. 一、二、三范式：1NF每一列不可分割；2NF每一行都可以被唯一标记；3NF任何非主属性不依赖于其它非主属性，也就是不能冗余；
5. 防止SQL注入：过滤用户输入；转义sql语句；使用参数化的sql，不要动态拼接；对于php配置安全策略；错误信息不要暴露给用户；sql检测；w
6. 表的设计应该注意什么？
7. 数据库主键怎么理解：主键作为一行的唯一标记，可以强制表的完整性约束，
8. mysql主从原理；


### 操作系统&网络
1. 进程和线程的区别？进程之间的通信方式？
进程是资源分配的最小单位，线程是cpu调度的最小单位，线程共可共用进程的资源。
管道、信号、消息队列、共享内存.
2. tcp流量控制？拥塞控制？
对端通过ack报文告知接收窗口大小，本段发送报文不超过端口的大小；
慢开始、避免拥塞、快重传、快恢复
3. tcp为什么是四次挥手
tcp是全双工连接
4. tcp为什么是可靠的
确认和重传机制；数据排序；流量控制；拥塞控制；



### 系统设计
1. 请求比较大，应该从哪方面优化
应用水平扩展，应用水平拆分，缓存（客户端，服务端），异步，
2. 如何做限流？
应用层限流、分布式限流、接入层限流；
3. restful的优缺点：
面向资源，将资源松耦合；
中间件可以根据动作来判断是否需要缓存；
### 设计模式


# 慢查询
## 1.优化数据访问
##### 是否请求了不需要的数据：
> 请求了多余的列；
> 请求了多余的行；
##### 是否扫描了额外的数据：
衡量查询的三个指标：相应时间，扫描的行数，返回的行数；这三个指标都会记录到慢查询日志中。
> 可以通过explain命令确认查询访问的类型，以及扫描的行数等；
## 2.重构查询 
##### 一个复杂查询还是多个简单查询
虽然mysql扫描数据的速度要比响应客户端的速度要快很多，尽可能使用少的查询次数是最好的，但有时候将一个大查询分解成多个小查询是有必要的。  
##### 切分查询，也就是分页查询
##### 分解关联查询
> 缓存的效率更高，关联查询一个表的缓存失效后，整个查询就不能使用缓存了；
> 单个查询减少锁的竞争；
> 应用层做关联，数据库容易做拆分；
> 应用层做关联，减少数据的访问，联合查询可能要重复扫描一部分数据；  

